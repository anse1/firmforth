\ -*- forth -*-
\ Use firmforth primitives to define more words from the CORE section
\ of the ANS94 standard.
\
\ The early definitions look very inelegant, but they get better as
\ the language is extended and becomes more usable.  Libfirm's
\ optimizations do a pretty good job at removing lots of the apparent
\ inefficiencies in these definitions.

: 1+ 1 + ;

: 2 1 1+ ;
: 3 2 1+ ;
: 4 3 1+ ;
: 5 4 1+ ;

: -1 1 negate ;
: -2 2 negate ;
: -3 3 negate ;
: -4 4 negate ;
: -5 5 negate ;

: invert 1+ negate ;

: - negate + ;
: 1- -1 + ;

: 0= ( x1 -- flag )
	if 0 else 1 then ;

: < ( x1 x2 -- flag )
	1- > 0= ;

: 2drop ( a b -- )
  drop drop ;

: dup ( a -- a a )
  0 pick ;

: over ( x1 x2 -- x1 x2 x1 )
	1 pick ;

: 2dup ( x1 x2 -- x1 x2 x1 x2 )
  over over ;

: 2over ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
  3 pick 3 pick ;
  
: while postpone if ; immediate

: ?dup dup if dup then ;

: 2* 1 lshift ;
: 2/ 1 rshift ;

: constant
  postpone :
  postpone tarval
  postpone ;
;

: variable
  postpone :
  1 cells allocate drop
  postpone tarval
  postpone ;
;

: +!
  dup @ 2 pick + swap ! ;

\ Various example programs

: fibonacci
	dup 0= if
	else
		dup 1 = if
		else
			1 - dup fibonacci
			swap 1 - fibonacci +
		then
	then ;

: factorial ( n -- n! )
    dup 1 >  if
        dup 1-  factorial  *
    then ;

\ adapted from https://rosettacode.org/wiki/N-queens_problem#Forth

variable solutions
variable nodes
 
: bits ( n -- mask ) 1 swap lshift 1- ;
: lowBit  ( mask -- bit ) dup negate and ;
: lowBit- ( mask -- bits ) dup 1- and ;

: next3 ( dl dr f files -- dl dr f dl' dr' f' )
  invert >r
  2 pick r@ and 2* 1+
  2 pick r@ and 2/
  2 pick r> and ;
 
: try ( dl dr f -- )
  dup if
    1 nodes +!
    dup 2over and and
    begin ?dup while
      dup >r lowBit next3 try r> lowBit-
    repeat
  else 1 solutions +! then
  drop 2drop ;
 
: queens ( n -- )
  0 solutions ! 0 nodes !
  -1 -1 rot bits try
  solutions @ . nodes @ .  ;
 
8 queens  \ 92 solutions, 1965 nodes

